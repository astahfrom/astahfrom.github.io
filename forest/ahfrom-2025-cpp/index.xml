<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/forest/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/forest/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/forest/ahfrom/" title="Asta Halkjær From" uri="https://astahfrom.github.io/forest/ahfrom/" display-uri="ahfrom" type="local">Asta Halkjær From</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
    </fr:date>
    <fr:uri>https://astahfrom.github.io/forest/ahfrom-2025-cpp/</fr:uri>
    <fr:display-uri>ahfrom-2025-cpp</fr:display-uri>
    <fr:route>/forest/ahfrom-2025-cpp/</fr:route>
    <fr:title text="An Isabelle/HOL Framework for Synthetic Completeness Proofs">An Isabelle/HOL Framework for Synthetic Completeness Proofs</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="doi">10.1145/3703595.3705882</fr:meta>
    <fr:meta name="venue">In K. Stark et al (ed.) Proceedings of the 14th ACM SIGPLAN International Conference on Certified Programs and Proofs (CPP 2025)</fr:meta>
    <fr:meta name="slides">/forest/bafkrmig7aq7xnj4hn3sqzld7unlsy5kttfe7gpaw6drrn3ro64o3nrhluq.pdf</fr:meta>
    <fr:meta name="bibtex"><![CDATA[@inproceedings{DBLP:conf/cpp/From25,
abstract = {Proof assistants like Isabelle/HOL provide the perfect opportunity to develop more than just one-off formalizations, but frameworks for developing new results within a given area. Completeness results for logical calculi often include bespoke versions of Lindenbaum's lemma. In this paper, I mechanize an abstract, transfinite version of the lemma and use it to build witnessed, maximal consistent sets (MCSs) for any notion of consistency that satisfies a few requirements. I prove abstract results about when MCSs reflect the proof rules of the underlying calculi. Finally, I formalize a process for mechanically calculating saturated set conditions from a given logic's semantics. This separates the truth lemma that connects MCS-membership and satisfiability into semantic and syntactic components, giving concrete proof obligations for each operator of the logic. To illustrate the framework's applicability, I instantiate it with propositional, first-order, modal and hybrid logic examples. I mechanize strong completeness for each logic, even for uncountably large languages, proving that, if a formula is valid under a set of assumptions, then we can derive it from a finite subset.},
author = {Asta Halkj{æ}r From},
booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} International Conference on Certified Programs and Proofs, {CPP} 2025, Denver, CO, USA, January 20-21, 2025},
doi = {10.1145/3703595.3705882},
editor = {Kathrin Stark and Amin Timany and Sandrine Blazy and Nicolas Tabareau},
pages = {171--186},
publisher = {{ACM}},
title = {An Isabelle/HOL Framework for Synthetic Completeness Proofs},
year = {2025},
}]]></fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>Proof assistants like Isabelle/HOL provide the perfect opportunity to develop more than just one-off formalizations, but frameworks for developing new results within a given area. Completeness results for logical calculi often include bespoke versions of Lindenbaum's lemma. In this paper, I mechanize an abstract, transfinite version of the lemma and use it to build witnessed, maximal consistent sets (MCSs) for any notion of consistency that satisfies a few requirements. I prove abstract results about when MCSs reflect the proof rules of the underlying calculi. Finally, I formalize a process for mechanically calculating saturated set conditions from a given logic's semantics. This separates the truth lemma that connects MCS-membership and satisfiability into semantic and syntactic components, giving concrete proof obligations for each operator of the logic. To illustrate the framework's applicability, I instantiate it with propositional, first-order, modal and hybrid logic examples. I mechanize strong completeness for each logic, even for uncountably large languages, proving that, if a formula is valid under a set of assumptions, then we can derive it from a finite subset.</html:p>
    <html:p>
      <fr:link href="/forest/ahfrom-2023-afp-synthetic-completeness/" title="Synthetic Completeness" uri="https://astahfrom.github.io/forest/ahfrom-2023-afp-synthetic-completeness/" display-uri="ahfrom-2023-afp-synthetic-completeness" type="local" />
    </html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/ahfrom/" title="Asta Halkjær From" uri="https://astahfrom.github.io/forest/ahfrom/" display-uri="ahfrom" type="local">Asta Halkjær From</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
            </fr:date>
            <fr:uri>https://astahfrom.github.io/forest/ahfrom-2023-afp-synthetic-completeness/</fr:uri>
            <fr:display-uri>ahfrom-2023-afp-synthetic-completeness</fr:display-uri>
            <fr:route>/forest/ahfrom-2023-afp-synthetic-completeness/</fr:route>
            <fr:title text="Synthetic Completeness">Synthetic Completeness</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="external">https://isa-afp.org/entries/Synthetic_Completeness.html</fr:meta>
            <fr:meta name="venue">
              <fr:link href="/forest/afp/" title="Archive of Formal Proofs" uri="https://astahfrom.github.io/forest/afp/" display-uri="afp" type="local">Archive of Formal Proofs</fr:link>
            </fr:meta>
            <fr:meta name="bibtex"><![CDATA[@article{Synthetic_Completeness-AFP,
abstract = {In this work, I provide an abstract framework for proving the completeness of a logical calculus using the synthetic method. The synthetic method is based on maximal consistent saturated sets (MCSs). A set of formulas is consistent (with respect to the calculus) when we cannot derive a contradiction from it. It is maximally consistent when it contains every formula that is consistent with it. For logics where it is relevant, it is saturated when it contains a witness for every existential formula. To prove completeness using these maximal consistent saturated sets, we prove a truth lemma: every formula in an MCS has a satisfying model. Here, Hintikka sets provide a useful stepping stone. These can be seen as characterizations of the MCSs based on simple subformula conditions rather than via the calculus. We then prove that every Hintikka set gives rise to a satisfying model and that MCSs are Hintikka sets. Now, assume a valid formula cannot be derived. Then its negation must be consistent and therefore satisfiable. This contradicts validity and the original formula must be derivable. To start, I build maximal consistent saturated sets for any logic that satisfies a small set of assumptions. I do this using a transfinite version of Lindenbaum's lemma, which allows me to support languages of any cardinality. I then prove useful abstract results about derivations and refutations as they relate to MCSs. Finally, I show how Hintikka sets can be derived from the logic's semantics, outlining one way to prove the required truth lemma. To demonstrate the versatility of the framework, I instantiate it with five different examples. The formalization contains soundness and completeness results for: a propositional tableau calculus, a propositional sequent calculus, an axiomatic system for modal logic, a labelled natural deduction system for hybrid logic and a natural deduction system for first-order logic. The tableau example uses custom Hintikka sets based on the calculus, but the other four examples derive them from the semantics in the style of the framework. The hybrid and first-order logic examples rely on saturated MCSs. This places requirements on the cardinalities of their languages to ensure that there are enough witnesses available. In both cases, the type of witnesses must be infinite and have cardinality at least that of the type of propositional/predicate symbols.},
author = {Asta Halkjær From},
issn = {2150-914x},
journal = {Archive of Formal Proofs},
month = {January},
title = {Synthetic Completeness},
url = {https://isa-afp.org/entries/Synthetic_Completeness.html},
year = {2023},
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>In this work, I provide an abstract framework for proving the completeness of a logical calculus using the synthetic method. The synthetic method is based on maximal consistent saturated sets (MCSs). A set of formulas is consistent (with respect to the calculus) when we cannot derive a contradiction from it. It is maximally consistent when it contains every formula that is consistent with it. For logics where it is relevant, it is saturated when it contains a witness for every existential formula. To prove completeness using these maximal consistent saturated sets, we prove a truth lemma: every formula in an MCS has a satisfying model. Here, Hintikka sets provide a useful stepping stone. These can be seen as characterizations of the MCSs based on simple subformula conditions rather than via the calculus. We then prove that every Hintikka set gives rise to a satisfying model and that MCSs are Hintikka sets. Now, assume a valid formula cannot be derived. Then its negation must be consistent and therefore satisfiable. This contradicts validity and the original formula must be derivable. To start, I build maximal consistent saturated sets for any logic that satisfies a small set of assumptions. I do this using a transfinite version of Lindenbaum's lemma, which allows me to support languages of any cardinality. I then prove useful abstract results about derivations and refutations as they relate to MCSs. Finally, I show how Hintikka sets can be derived from the logic's semantics, outlining one way to prove the required truth lemma. To demonstrate the versatility of the framework, I instantiate it with five different examples. The formalization contains soundness and completeness results for: a propositional tableau calculus, a propositional sequent calculus, an axiomatic system for modal logic, a labelled natural deduction system for hybrid logic and a natural deduction system for first-order logic. The tableau example uses custom Hintikka sets based on the calculus, but the other four examples derive them from the semantics in the style of the framework. The hybrid and first-order logic examples rely on saturated MCSs. This places requirements on the cardinalities of their languages to ensure that there are enough witnesses available. In both cases, the type of witnesses must be infinite and have cardinality at least that of the type of propositional/predicate symbols.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/ahfrom/" title="Asta Halkjær From" uri="https://astahfrom.github.io/forest/ahfrom/" display-uri="ahfrom" type="local">Asta Halkjær From</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>5</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>https://astahfrom.github.io/forest/thinking-helix/</fr:uri>
            <fr:display-uri>thinking-helix</fr:display-uri>
            <fr:route>/forest/thinking-helix/</fr:route>
            <fr:title text="Thinking Helix">Thinking Helix</fr:title>
            <fr:taxon>Post</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>I learned to touch type with Colemak. Before I even started high school, I figured that my life would contain a lot of typing, and that I should make it as easy as possible. I started dabbling with Vim around the same time and I have used Vim bindings in everything from Emacs to Overleaf to Visual Studio Code since then. At some point I started using Neovim in a modern terminal because the responsiveness felt unbeatable.</html:p>
            <html:p>Last year, after reading about <fr:link href="https://helix-editor.com/" type="external">Helix</fr:link> again and again, I decided to try to write my <fr:link href="/forest/ahfrom-2025-cpp/" title="An Isabelle/HOL Framework for Synthetic Completeness Proofs" uri="https://astahfrom.github.io/forest/ahfrom-2025-cpp/" display-uri="ahfrom-2025-cpp" type="local">CPP paper</fr:link> in it. I gave up almost immediately because the <fr:link href="https://kakoune.org/" type="external">Kakoune</fr:link>-style of editing was too difficult to get used to with a deadline hanging over my head.</html:p>
            <html:p>However, I kept reading about Helix. Everyone seemed to not just love it, but find it superior to Vim. I did some experiments with Helix's built-in tutor, but I still could not wrap my head around it. On those kinds of micro-benchmarks where you make a single edit in a vacuum, Vim's style felt easily superior to me. It was more or less designed to get a lot done with few keystrokes. Despite reading a bunch of posts about how Helix felt more natural to people, it took a conversation with my partner to understand what Helix does so well.</html:p>
            <html:p><html:em>Helix is coherent.</html:em> Neovim builds on almost fifty years of decisions. Helix is much younger: not just from this millenium, but from this decade. Moreover, and to their credit, they have not been afraid to break with tradition. Why should <html:code>0</html:code> move to the start of line? The more coherent choice is <html:code>gh</html:code> (go home). That further enables Helix's great discoverability: tap <html:code>g</html:code> and Helix will show you follow-up keys and what they do. Oh, <html:code>ge</html:code> goes to the end of the file. Neat!</html:p>
            <html:p><html:em>Helix is familiar.</html:em> It chose Kakoune's modal editing rather than Vim's. In Notepad, you select some text and then you copy it. In Word, you select some text and then you italicize it. In Helix, you select some text and then you act on it. Helix is familiar. I can see why people say they make fewer mistakes in Helix: they can see what they are doing! This ties back into the coherence. In Vim <html:code>~</html:code>, <html:code>r</html:code> and <html:code>x</html:code> all act immediately. You need to be in visual mode to act on more than the character under the cursor. It would be more coherent if they took an object like <html:code>d</html:code>, <html:code>c</html:code> and <html:code>y</html:code> all do. In Helix this is uniform: everything acts on selections and your cursor is just a one-character selection.</html:p>
            <html:p><html:em>Helix works out of the box.</html:em> Helix does not have a plugin system and you probably will not miss one. Helix is engineered from the beginning for <fr:link href="https://tree-sitter.github.io/tree-sitter/" type="external">tree-sitter</fr:link> and <fr:link href="https://microsoft.github.io/language-server-protocol/" type="external">Language Server Protocol</fr:link> support. Auto-complete is built in. The file picker is built in. ace-jump-mode slash Avy slash EasyMotion slash leap.nvim is built in as <html:code>gw</html:code> (go to word). Oh, and it also has multiple cursors.</html:p>
            <html:p>At this point, I was back to being curious about Helix. After reading about <fr:link href="https://felix-knorr.net/posts/2025-03-16-helix-review.html" type="external">Felix Knorr's choice to use Helix over Neovim</fr:link>, despite being as unconvinced as me that the style is more effective, I decided to give Helix another go. Since then, I've been using Helix for writing slides, refining peer review, re-doing my homepage, editing config files, and so on. We are nowhere near my experince with Vim bindings, and we are still months away from giving Helix a fair shot, but I do not want to use Helix anymore. I want to go back to Neovim. I absolutely love the speed, the ease-of-use and the various pickers of Helix, but I cannot get used to it.</html:p>
            <html:p><html:em>I do not need coherence. I am familiar with Vim.</html:em> Commands like <html:code>$</html:code>, <html:code>C</html:code>, and <html:code>dd</html:code> might not be immediately intuitive, but that does not matter to me. I have already learned them. I am already thinking in terms of them. Spending two keypresses just to go to the end of the line feels coherent but burdensome. Tapping two different keys (<html:code>xd</html:code>) just to delete a line feels tedious. It might be good for discoverability and uniformity to jump a paragraph with <html:code><![CDATA[]p]]></html:code>, but  <html:code><![CDATA[}]]></html:code> feels <html:em>easier</html:em> when skimming through a file. Moreover, Helix still feels young to me. Like all of Helix's <html:code>g</html:code> actions, <html:code>gl</html:code> merely jumps, it does not select (to the end of the line). As a consequence, I never found a good substitute for Vim's <html:code>C</html:code> (change the rest of the line). Maybe <html:code>vglc</html:code>: enter select mode, go to the end of the line, change the selection? Perhaps <html:code>t&lt;Enter&gt;c</html:code>: select to the newline character, change the selection, and pray that you were not on the last line of the file? The cost of coherence feels mighty high to me, but the problem is probably the following.</html:p>
            <html:p><html:em>I struggle to think Helix.</html:em> I am sitting in front of my computer with my cursor in the middle of a "-quoted string and I want to swap out its contents. How do you think that in Helix? I am used to thinking in Vim. I think <html:em>change inside the quotes</html:em> (<html:code>ci"</html:code>). I do not think in Notepad, Word or Kakoune. I do not think <html:em>mark inside the quotes and change the selection</html:em> (<html:code>mi"c</html:code>). That feels indirect to me. What do I care about selecting the stuff I want gone? I just want to put some new text inside these quotes.</html:p>
            <html:p>I did spend enough time with Helix that I could sometimes plan out my selections in a much smoother way. A well placed <html:code>v</html:code> feels the same as inserting a seemingly innocuous rotation in fewest-moves cubing: down the line, it makes everything work out. It feels good in Helix to jump a few words forward with <html:code>w</html:code> and immediately press <html:code>c</html:code> to change the highlighted word. Here, Vim's <html:code>ciw</html:code> feels just a little bit clunkier. However, the micro-benchmarks won out in the end. I could not get used to the cost of uniformity. Selections kept feeling indirect. I got confused every time <html:code>i</html:code> inserted at the beginning of my (accidental) selection rather than at the position of my cursor. That mental overload vastly outweighed the benefit of <html:em>seeing what I am doing</html:em>. In my experience, Vim makes undo cheap. Thinking Helix was not nearly as cheap.</html:p>
            <html:p>I should have learned Helix's multiple cursors. I see how they fit the model. I see the coherence and the familiarity, but oh dear, now I have to keep track of both selections <html:em>and</html:em> cursors? The unfamiliarity blows my complexity budget. Besides, I struggle to understand their granularity. Adding an extra cursor one at a time, Helix's <html:code>C</html:code>, feels incredibly tedious to me. You've lost me after two cursors. On the other hand, splitting a selection on a regex feels incredibly powerful, but if I am already thinking in regular expressions, then why throw cursors into the mix? I guess Helix's <html:code>A-s</html:code> (split selection on newlines) could have been my friend, as a close cousin to Vim's <html:em>visual block mode</html:em>, which I love dearly, but it would have taken work. How do you even wield this thing? <html:code><![CDATA[ ]pvkA-sI]]></html:code>: select next paragraph, enter select mode to unselect the one line that we jumped too far, split on newlines, start inserting at the beginning of the selection? Also, recall that comma (<html:code>,</html:code>), not Escape, clears the cursors afterwards? I am clearly out of my depth. (EDIT: <html:code><![CDATA[ mipA-sI]]></html:code> works well). In Vim, I would do something like <html:code><![CDATA[ C-v}kI]]></html:code> to achieve the same thing. However, this is an unfair comparision. I am thinking in the language of Vim and trying to do the same thing in Helix. I struggle to think Helix. Luckily, I am content with thinking Vim.</html:p>
            <html:p>This leaves the out-of-box behaviour. I am not going to claim that 214 lines of Lua turn Neovim into Helix. Helix is extremely polished. Helix is already at version 25.01.1 while Neovim is merely at version 0.11. I will share with you my 214 lines of Lua anyway. I am a big fan of <fr:link href="https://github.com/echasnovski/mini.nvim" type="external">mini.nvim</fr:link> and that makes up the bulk of the configuration. However, after using Helix for a while, I find mini.pick too spartan, so here <fr:link href="https://github.com/nvim-telescope/telescope.nvim" type="external">telescope.nvim</fr:link> takes the stage. It offers the same delightful preview window as Helix's pickers. Tree-sitter and LSP are not as built in, but can be easily and delightfully declaratively configured. I have also discovered <fr:link href="https://github.com/echasnovski/mini.nvim/blob/main/readmes/mini-clue.md" type="external">mini.clue</fr:link>, which, at the cost of some configuration, offers similar discoverability to Helix. The below configuration makes me happy. Tapping <html:code>C</html:code> and <html:code><![CDATA[}]]></html:code> and <html:code>ci"</html:code> makes me happy. Let us see how long it lasts.</html:p>
            <html:pre><![CDATA[-- mini.nvim

local path_package = vim.fn.stdpath('data') .. '/site'
local mini_path = path_package .. '/pack/deps/start/mini.nvim'
if not vim.loop.fs_stat(mini_path) then
  vim.cmd('echo "Installing `mini.nvim`" | redraw')
  local clone_cmd = {
    'git', 'clone', '--filter=blob:none',
    'https://github.com/echasnovski/mini.nvim', mini_path
  }
  vim.fn.system(clone_cmd)
  vim.cmd('packadd mini.nvim | helptags ALL')
end

-- mini.deps

require('mini.deps').setup({})
local add = MiniDeps.add

-- options

vim.g.maplocalleader = ","

local opt = vim.opt

opt.background = "light"
opt.tabstop = 2
opt.shiftwidth = 2
opt.expandtab = true
opt.wrap = true

-- colorscheme: atom one light

require('mini.base16').setup({
  palette = {
    base00 = "#fafafa",
    base01 = "#f0f0f1",
    base02 = "#e5e5e6",
    base03 = "#a0a1a7",
    base04 = "#696c77",
    base05 = "#383a42",
    base06 = "#202227",
    base07 = "#090a0b",
    base08 = "#ca1243",
    base09 = "#d75f00",
    base0A = "#c18401",
    base0B = "#50a14f",
    base0C = "#0184bc",
    base0D = "#4078f2",
    base0E = "#a626a4",
    base0F = "#986801",
  }
})

-- defaults

vim.diagnostic.config({ virtual_text = true })
vim.lsp.inlay_hint.enable(true)

require("mini.basics").setup({
  options = { extra_ui = true },
  mappings = { windows = true },
})

require("mini.notify").setup({})

-- editing

require("mini.ai").setup({})
require("mini.pairs").setup({})
require("mini.surround").setup({})
require("mini.comment").setup({})
require("mini.bracketed").setup({})

local map_multistep = require('mini.keymap').map_multistep

map_multistep('i', '<Tab>',   { 'pmenu_next' })
map_multistep('i', '<S-Tab>', { 'pmenu_prev' })
map_multistep('i', '<CR>',    { 'pmenu_accept', 'minipairs_cr' })
map_multistep('i', '<BS>',    { 'minipairs_bs' })

-- version control

require("mini.git").setup({})
require("mini.diff").setup({})

-- statusline

require("mini.icons").setup({})
require("mini.statusline").setup({})

-- Completion

require("mini.snippets").setup({})
require("mini.completion").setup({
  fallback_action = "<C-x><C-z>",
})

-- pickers

add({
  source = "nvim-telescope/telescope.nvim",
  depends = { "nvim-lua/plenary.nvim" },
})

local actions = require("telescope.actions")
require("telescope").setup({
  defaults = {
    mappings = {
      i = {
        -- Close picker immediately on Escape
        ["<ESC>"] = actions.close,
      }
    }
  }
})

-- Inspired by Helix mappings
local builtin = require('telescope.builtin')
vim.keymap.set('n', '<Leader>f', builtin.find_files, { desc = 'Find files' })
vim.keymap.set('n', '<Leader>o', function() builtin.find_files({ cwd = vim.fn.expand('%:p:h') }) end, { desc = 'Find files in buffer directory' })
vim.keymap.set('n', '<Leader>b', builtin.buffers, { desc = 'Buffers' })
vim.keymap.set('n', '<Leader>s', builtin.lsp_document_symbols, { desc = 'Document symbols' })
vim.keymap.set('n', '<Leader>S', builtin.lsp_workspace_symbols, { desc = 'Workspace symbols' })
vim.keymap.set('n', '<Leader>d', builtin.lsp_document_symbols, { desc = 'Diagnostics' })
vim.keymap.set('n', '<Leader>/', builtin.live_grep, { desc = 'Live grep' })
vim.keymap.set('n', '<Leader>t', builtin.treesitter, { desc = 'Tree-sitter' })

-- tree-sitter

add({
  source = "nvim-treesitter/nvim-treesitter",
  hooks = { post_checkout = function() vim.cmd('TSUpdate') end },
})

require("nvim-treesitter.configs").setup({
  ensure_installed = { "lua" },
  highlight = {
    enable = true,
    additional_vim_regex_highlighting = false,
  }
})

-- lspconfig

add({
  source = "neovim/nvim-lspconfig",
  depends = { "mason-org/mason.nvim", "mason-org/mason-lspconfig.nvim" },
})

require("mason").setup({})
require("mason-lspconfig").setup({
  ensure_installed = { "lua_ls" },
})

-- clues

local miniclue = require("mini.clue")
miniclue.setup({
  triggers = {
    -- Leader triggers
    { mode = 'n', keys = '<Leader>' },
    { mode = 'x', keys = '<Leader>' },

    -- Built-in completion
    { mode = 'i', keys = '<C-x>' },

    -- `g` key
    { mode = 'n', keys = 'g' },
    { mode = 'x', keys = 'g' },

    -- Marks
    { mode = 'n', keys = "'" },
    { mode = 'n', keys = '`' },
    { mode = 'x', keys = "'" },
    { mode = 'x', keys = '`' },

    -- Registers
    { mode = 'n', keys = '"' },
    { mode = 'x', keys = '"' },
    { mode = 'i', keys = '<C-r>' },
    { mode = 'c', keys = '<C-r>' },

    -- Window commands
    { mode = 'n', keys = '<C-w>' },

    -- `z` key
    { mode = 'n', keys = 'z' },
    { mode = 'x', keys = 'z' },

    -- mini.bracketed
    { mode = 'n', keys = '[' },
    { mode = 'n', keys = ']' },

    -- mini.surround
    { mode = 'n', keys = 's' },
  },

  clues = {
    miniclue.gen_clues.builtin_completion(),
    miniclue.gen_clues.g(),
    miniclue.gen_clues.marks(),
    miniclue.gen_clues.registers(),
    miniclue.gen_clues.windows(),
    miniclue.gen_clues.z(),
  },
  window = {
    delay = 0,
    config = {
      width = 40,
    },
  }
})]]></html:pre>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/forest/ahfrom/" title="Asta Halkjær From" uri="https://astahfrom.github.io/forest/ahfrom/" display-uri="ahfrom" type="local">Asta Halkjær From</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2023</fr:year>
              <fr:month>1</fr:month>
              <fr:day>31</fr:day>
            </fr:date>
            <fr:uri>https://astahfrom.github.io/forest/ahfrom-2023-phd-thesis/</fr:uri>
            <fr:display-uri>ahfrom-2023-phd-thesis</fr:display-uri>
            <fr:route>/forest/ahfrom-2023-phd-thesis/</fr:route>
            <fr:title text="Formally Correct Deduction Methods for Computational Logic">Formally Correct Deduction Methods for Computational Logic</fr:title>
            <fr:taxon>Reference</fr:taxon>
            <fr:meta name="venue">PhD thesis, <fr:link href="/forest/dtu/" title="Technical University of Denmark" uri="https://astahfrom.github.io/forest/dtu/" display-uri="dtu" type="local">Technical University of Denmark</fr:link></fr:meta>
            <fr:meta name="slides">/forest/bafkrmihlakseuvtsrtlywgufu6u7td4va5ezlfnlvwapqbfekcjubtxee4.pdf</fr:meta>
            <fr:meta name="external">/forest/bafkrmia3dddrsbaogkrwfwjc3i4f3vdjhq6rlnoziegwyk5veymmgzlnfa.pdf</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Advisors: <fr:link href="/forest/jvilladsen/" title="Jørgen Villadsen" uri="https://astahfrom.github.io/forest/jvilladsen/" display-uri="jvilladsen" type="local">Jørgen Villadsen</fr:link> and <fr:link href="/forest/ngierasimczuk/" title="Nina Gierasimczuk" uri="https://astahfrom.github.io/forest/ngierasimczuk/" display-uri="ngierasimczuk" type="local">Nina Gierasimczuk</fr:link>.</html:p>
            <html:p>Some logics make it easier to say what we want than others and some methods of deduction are simpler to work with than others. One thing typically remains important: that we can deduce all valid things (completeness). In this thesis I tackle completeness of various deduction methods for various logics. The work is formalized in the proof assistant Isabelle/HOL which offers a common language for mathematics and computer science where proofs can be checked mechanically. This thesis discusses the following contributions of my PhD project in particular:
<html:ul><html:li><fr:link href="/forest/ahfrom-2021-esslli/" title="Formalizing Henkin-Style Completeness of an Axiomatic System for Propositional Logic" uri="https://astahfrom.github.io/forest/ahfrom-2021-esslli/" display-uri="ahfrom-2021-esslli" type="local">A historical overview of formalized completeness proofs and a formalization that explains the essence of synthetic completeness proofs.</fr:link></html:li>
<html:li><fr:link href="/forest/ahfrom-2021-types/" title="A Succinct Formalization of the Completeness of First-Order Logic" uri="https://astahfrom.github.io/forest/ahfrom-2021-types/" display-uri="ahfrom-2021-types" type="local">A formalization of a concise completeness proof for first-order logic in Isabelle/HOL, including solutions to the issues of formalizing quantifiers and proving completeness for formulas with free variables.</fr:link></html:li>
<html:li><fr:link href="/forest/ahfrom-fkjacobsen-2022-itp/" title="Verifying a Sequent Calculus Prover for First-Order Logic with Functions in Isabelle/HOL" uri="https://astahfrom.github.io/forest/ahfrom-fkjacobsen-2022-itp/" display-uri="ahfrom-fkjacobsen-2022-itp" type="local">A verified prover for first-order logic with functions, with a formalized completeness proof that takes the search strategy of the prover into account.</fr:link></html:li>
<html:li><fr:link href="/forest/ahfrom-2020-types/" title="Synthetic Completeness for a Terminating Seligman-Style Tableau System" uri="https://astahfrom.github.io/forest/ahfrom-2020-types/" display-uri="ahfrom-2020-types" type="local">A synthetic completeness proof for a tableau system for basic hybrid logic which is both terminating and in the Seligman style where the proof rules reflect the local perspective that modal logic is based on.</fr:link></html:li>
<html:li><fr:link href="/forest/ahfrom-2024-jlc-wollic/" title="Formalized Soundness and Completeness of Epistemic and Public Announcement Logic" uri="https://astahfrom.github.io/forest/ahfrom-2024-jlc-wollic/" display-uri="ahfrom-2024-jlc-wollic" type="local">Formalized soundness and completeness results for epistemic and public announcement logic, instantiated to a range of concrete axiom systems.</fr:link></html:li>
<html:li><fr:link href="/forest/jlimperg-ahfrom-2023-cpp/" title="Aesop: White-Box Best-First Proof Search for Lean" uri="https://astahfrom.github.io/forest/jlimperg-ahfrom-2023-cpp/" display-uri="jlimperg-ahfrom-2023-cpp" type="local">A best-first proof search tactic for the proof assistant Lean 4.</fr:link></html:li>
<html:li><fr:link href="/forest/ahfrom-2025-cpp/" title="An Isabelle/HOL Framework for Synthetic Completeness Proofs" uri="https://astahfrom.github.io/forest/ahfrom-2025-cpp/" display-uri="ahfrom-2025-cpp" type="local">An abstract framework for synthetic completeness proofs.</fr:link></html:li></html:ul></html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
